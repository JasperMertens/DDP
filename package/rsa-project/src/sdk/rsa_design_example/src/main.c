#include <stdio.h>
#include <stdlib.h>

#include "xil_printf.h"
#include "xil_cache.h"

#include "platform/platform.h"
#include "platform/performance_counters.h"

#include "interface.h"
#include "sw.h"
#include "hw.h"

///////////////////////////////////////////////////////////
#include "montgomery2.h"
///////////////////////////////////////////////////////////

// These variables are defined and assigned in testvector.c
extern uint32_t M[32],
                N[32],       N_prime[32],
                e[32],
                e_len,
                p[16],       q[16],
                d_p[16],     d_q[16],
                d_p_len, d_q_len,
                x_p[32],     x_q[32],
				Rp[16],		Rq[16],
                R2p[16],     R2q[16],
                R_1024[32],  R2_1024[32],
                One[32];


// Note that these tree CMDs are same as
// they are defined in montgomery_wrapper.v
#define CMD_READ    0
#define CMD_COMPUTE 1
#define CMD_WRITE   2

void test_mp_sub();
void test_mp_add();
void test_mod_add();
void test_mont_mult();
void test_mont_exp();
void printMontResult();
void test_hw_mont_mult();
void test_hw_mont_exp();
void test_hw_mont_decrypt();

uint32_t result[32] = {0};
uint32_t size = 32;


int main()
{

    init_platform();
    init_performance_counters(1);
    interface_init();

    xil_printf("\n\r Startup..\n\r");

    START_TIMING

	//test_dma_transfer();

	//test_mp_add();

	//test_mp_sub();

	//test_mod_add();
    
    //test_mont_mult();

	//test_hw_mont_mult();

    test_mont_exp();

	//test_hw_mont_exp();

	//test_hw_mont_decrypt();
    //printMontExpResult(32);

    STOP_TIMING

    ////////////// Test the port-based communication //////////////

	//// --- Create and initialize src array

#if NUMBER_OF_CORES == 1
	// If NUMBER_OF_CORES == 1
	// then all 16 words defined below will be used to communicate with Core 1

	unsigned int src[DMA_TRANSFER_NUMBER_OF_WORDS]={
		0x00000000, 0x00000000, 0x01234567, 0x89abcdef,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000};
#else
    // If NUMBER_OF_CORES == 2
    // then 32 words will be defined,
    //      the words  0 to 15 will be used to communicate with Core 1
    //      the words 16 to 31 will be used to communicate with Core 2

    unsigned int src[DMA_TRANSFER_NUMBER_OF_WORDS]={
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x76543210, 0xfedcba98, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x89abcdef, 0x01234567, 0x00000000, 0x00000000};

    // If you need, you can use the src1 and src2 pointers
    // to access the src array defined above as two individual arrays.
    // src1 for the lower  16-words of the src array and
    // src2 for the higher 16-words
    unsigned int* src1 = src;
    unsigned int* src2 = src+16;
#endif
    //// --- Perform the send operation
//
//    // Start by writing CMD_READ to port1 (command port)
//    xil_printf("PORT1=%x\n\r",CMD_READ);
//    my_montgomery_port[0] = CMD_READ;
//
//    // Transfer the src array to BRAM
//    bram_dma_transfer(dma_config,src,DMA_TRANSFER_NUMBER_OF_WORDS);
//
//    // Wait for done of CMD_READ is done
//    // by waiting for port2 (acknowledgement port)
//    port2_wait_for_done();
//
//
//    //// --- Print BRAM contents
//
//    // For checking if send is successful
//    print_bram_contents();
//
//
////    //// --- Perform the compute operation
////
////    // Start by writing CMD_COMPUTE to port1 (command port)
////    xil_printf("PORT1=%x\n\r",CMD_COMPUTE);
////    my_montgomery_port[0] = CMD_COMPUTE;
////
////    // Wait for done of CMD_COMPUTE is done
////	// by waiting for port2 (aknowledgement port)
////    port2_wait_for_done();
//
//
//    //// --- Perform the read operation
//
//    // Start by writing CMD_WRITE to port1 (command port)
//    xil_printf("PORT1=%x\n\r",CMD_WRITE);
//    my_montgomery_port[0] = 5;
//
//    // Wait for done of CMD_WRITE is done
//    port2_wait_for_done(); //Wait until Port2=1
//
//
//    //// --- Print BRAM contents
//
//    // For receiving the read output of the computation
//    print_bram_contents();

    cleanup_platform();

    return 0;
}

void test_mont_mult() {

#define MULT_TESTVECTOR 1

	#if MULT_TESTVECTOR == 1
	uint32_t a[32] = 				{0xf484e847, 0x4ae251f1, 0xedfa617d, 0x58ab6bf4, 0x46bf4848, 0xf67c1061, 0x8811c17a, 0x578fde16, 0x493ee595, 0x1eafc4c3, 0xc4f11a2e, 0x8cb6fba7, 0x724c03a4, 0x2e6c1dbd, 0x57ebc43d, 0x3e6ee260, 0x4089c050, 0xf0384e03, 0x7357f72c, 0x87acb658, 0x7ea2490e, 0x61069112, 0x42e3f8b9, 0x9e778cef, 0x5cdf77c7, 0x10bce41c, 0x1121beec, 0x3db59a36, 0xc34620c5, 0xc6b030ae, 0xe8fc5934, 0x63a0a0cb};
	uint32_t b[32] = 				{0xfeb1b9f4, 0xe91d3bec, 0xfb09354d, 0x07f21d6d, 0x9ece9e1b, 0x18def18b, 0x4119e1e9, 0x55c85f24, 0x60ef0e23, 0x10e8ab54, 0x1e95cdcc, 0x4373912f, 0x6f42204d, 0x7126650d, 0xb61c1c8d, 0x98af9011, 0xa42c03b4, 0xd29e0870, 0x7923cb60, 0xdf87cfe5, 0xde4fffa0, 0x3ce537ca, 0x201040c6, 0x6e54b058, 0x814c53dc, 0xf16243f0, 0x57decf64, 0x8d0d4f37, 0x9b6d93e5, 0x45396d71, 0x615213c4, 0x65f89f9f};
	uint32_t N[32] = 				{0x4aeeb107, 0x5d78aa98, 0x6c55dd05, 0x6f5326c9, 0xf93f738c, 0xc10fa093, 0x20478120, 0x099d6d70, 0x833d9b82, 0x1248f3ed, 0xa43ed737, 0xc1c1da45, 0x9f23e5c7, 0xb17c3598, 0xe8938df6, 0x7ae59036, 0x9f84d87b, 0xc8710dc6, 0x249ee0f8, 0x46eeae2f, 0x66a3bb9b, 0xfeef4c6b, 0xc7b55eae, 0x7951dd0c, 0x0b4391e8, 0x141ad586, 0x1a568588, 0x908293dd, 0x472c0bea, 0x8d00abfe, 0xed17377f, 0x83a01efe};
	uint32_t n_prime[32] = 			{0xe7d41349, 0x0c828dcd, 0x2dc06d90, 0x318f87bf, 0x1992ba09, 0x4b1bef10, 0x011ba664, 0xe3a7d9cf, 0x44449fbd, 0x89714d34, 0x6cd49cc4, 0x49c5b99d, 0xf90435b1, 0x38f037b7, 0xba9720db, 0x9641b106, 0xbca01d2a, 0xfdb82893, 0xbd7ce9c7, 0x372823e1, 0x4901cdde, 0xaa28d457, 0xe9f78c94, 0xb6e1e5b3, 0x5a79f7a6, 0xf5212a83, 0x2b1aab45, 0xa3924b69, 0x3c63a8af, 0x12fa121d, 0x7500bea0, 0xe58878e7};
	uint32_t expected_output[32] = 	{0xeb7e3ef3, 0x40b90c4f, 0xd9c234b1, 0x2461cd34, 0x183481c7, 0x0bc4e5bd, 0x4803996e, 0x755d1777, 0x698f88c7, 0x2e78b03b, 0xa55cfb32, 0x74d1c12a, 0xc6bc8934, 0x581d4714, 0x7d504a58, 0xb29753f1, 0x99ae0c37, 0x65c4cc3a, 0x4153aacb, 0xe0a5c4bf, 0xce0a9c7c, 0x4babfb22, 0x75aa490d, 0x43b6ec25, 0xdcb17a10, 0x47deec3c, 0xd0e2735f, 0x16726b8e, 0x0f486246, 0x0f74d471, 0xe62a3577, 0x065a0397};

	#elif MULT_TESTVECTOR == 2
    uint32_t a[32] = 				{0x95401e33, 0xf2e5f538, 0xcd340e16, 0x5fe4fd66, 0xac500fe0, 0x748f18fe, 0xdad8575e, 0xce2058bb, 0x00c35266, 0xd51c8064, 0xfefeb38e, 0xc7ed29eb, 0xdb438313, 0x6550e48e, 0x02489732, 0xedaf8b6b, 0x5dd5313d, 0xa328f036, 0x419a784e, 0x23d635bb, 0x25143077, 0x48996382, 0xaa396499, 0xf24a2910, 0xb60ee4dc, 0xdfede44c, 0x69f174f6, 0x917d544c, 0x3c80aecf, 0xc90096c4, 0xc52a6c88, 0x07d92c14};
    uint32_t b[32] = 				{0xd7040630, 0xc765f25a, 0x4a7230d6, 0x395c2b8b, 0xaec10e86, 0xb62173f6, 0x72096da0, 0xc0ed3b81, 0x240e4293, 0xac5a2199, 0x5d05fed8, 0xadcae3e6, 0x22704082, 0x3b74cdb2, 0x51f0df68, 0xde5b7e6f, 0x66dc5f67, 0x0a836d5e, 0x32edcdb9, 0x4332989f, 0xedef232c, 0x25167785, 0x34d884aa, 0xfdf337de, 0xd7532d14, 0xa4b160f1, 0xf833b81c, 0xaa9589fb, 0xef7f7ade, 0x6ccff27d, 0x747a7bb0, 0x1f8042e7};
    uint32_t N[32] = 				{0xc6df4c85, 0x08e49be7, 0xe6f266e4, 0x450ca4b0, 0x028def7e, 0x3bdf79cf, 0xd3c65a9b, 0xd278192c, 0x08fd96bf, 0x5d635e17, 0xac3f28b1, 0x8449d487, 0xdd42688c, 0x61419fe8, 0x6b674328, 0x8f6bd9e2, 0x8e47420e, 0x94711c9e, 0x22f7165a, 0x2485755e, 0x61561df6, 0xf664e91d, 0xd97d05ce, 0xf221e0fd, 0xfd772f68, 0xf1856267, 0xe9041ac4, 0x2fd12fc8, 0x34b9220f, 0x695e5d77, 0x6b079c2c, 0x86ad4952};
    uint32_t n_prime[32] = 			{0x14d333b3, 0xc3b3be8f, 0x02ca4af0, 0xc43aba10, 0xde20e9cb, 0xc88222f9, 0x80860cc0, 0x315e4cf8, 0x0a2cc4f4, 0x16376d50, 0xcc1720b7, 0x8af0c35b, 0xc3ece9e9, 0x8f01dccc, 0x42d96568, 0xc02be3a4, 0x71e50c92, 0xb050887c, 0x4df93c3d, 0x75a13c65, 0xcd504fe2, 0x99ac5e4c, 0xc9f348e7, 0xb95f9a0e, 0xe170a1f0, 0x4769f246, 0x913001b4, 0xfc05df41, 0x63dc5efb, 0x9a863fbe, 0xc1f39f28, 0xf1295524};
    uint32_t expected_output[32] = 	{0xe4a627f2, 0x44ced61c, 0xb41445b2, 0x1deec41a, 0x00ec59c6, 0x366243e9, 0x8b3a5383, 0x293a279e, 0xb57482b8, 0x28a49995, 0xd5012ddd, 0xa1427bbf, 0xa4586c9c, 0x7df6bde0, 0x923e818c, 0xe215dbb8, 0x3a62ed6c, 0xe0f76529, 0x2d2936f3, 0x54e7fa14, 0x18022409, 0x6d5160c4, 0x998fe1c4, 0x86dab2c2, 0x46eda221, 0x6f93d1e2, 0xe9e57d26, 0xfb42688f, 0x679e9aa1, 0x6b70806a, 0x85d91b9f, 0x6a7decd7};

	#elif MULT_TESTVECTOR == 3
    uint32_t a[32] = 				{0x83bfde37, 0x4bb9caee, 0xa4b7bc55, 0x96e8674e, 0xaf6bbfe8, 0x0a527da7, 0xf7bc7ea0, 0xb699b8a8, 0x3920848d, 0xaeaf012f, 0x66ebd8c2, 0x5abead95, 0xae5a687b, 0x665240f4, 0x09cda19d, 0x44c26595, 0x9ab850d6, 0x18558d44, 0xf1bb0229, 0x76b9a3c1, 0x57e32029, 0x754ab74d, 0x67a4d489, 0xe225cb67, 0xaf4e9389, 0xe6487bd9, 0x6192265a, 0x2b91e006, 0xb603722b, 0x6b7d9fc5, 0xb23c36b6, 0xc9d91b54};
	uint32_t b[32] = 				{0x83bfde37, 0x4bb9caee, 0xa4b7bc55, 0x96e8674e, 0xaf6bbfe8, 0x0a527da7, 0xf7bc7ea0, 0xb699b8a8, 0x3920848d, 0xaeaf012f, 0x66ebd8c2, 0x5abead95, 0xae5a687b, 0x665240f4, 0x09cda19d, 0x44c26595, 0x9ab850d6, 0x18558d44, 0xf1bb0229, 0x76b9a3c1, 0x57e32029, 0x754ab74d, 0x67a4d489, 0xe225cb67, 0xaf4e9389, 0xe6487bd9, 0x6192265a, 0x2b91e006, 0xb603722b, 0x6b7d9fc5, 0xb23c36b6, 0xc9d91b54};
	uint32_t N[32] = 				{0x3b6021e5, 0x134c079f, 0xfde33b8f, 0xbaab11a1, 0x3c8c893c, 0xb1500200, 0xf9d24bba, 0xe222d5c3, 0x6cac296c, 0xb98e5642, 0x673bb3df, 0xbf622e6f, 0xcde92e10, 0x5b70b0f8, 0xbc0af8ba, 0x26111490, 0x930334b9, 0x66277177, 0x0e5f81f5, 0x7bfcaf4b, 0x8411f03a, 0xd0173f99, 0xd32ec72e, 0x53bdcc72, 0xcff9bece, 0x9aa667a9, 0x6fe3a78c, 0x02c749b4, 0xb1097967, 0x590ecd2d, 0x47583048, 0xd6369bca};
	uint32_t n_prime[1] = 			{0xb7bfcc13};
	uint32_t expected_output[32] = 	{0x32d84340, 0x3a3e6880, 0x3f632a75, 0x2ed7d896, 0x4e8177d9, 0x74458b42, 0xad6a9b6c, 0x25fc5bf2, 0x03217fcb, 0xd6d9ba7c, 0x29d1d141, 0xb156774f, 0x50731532, 0x46db2146, 0xb410bf5d, 0x3f048b1b, 0xeaa83826, 0x30eaf592, 0xd90cd3ff, 0xe8c4c0c3, 0xfe763e67, 0x742f8f31, 0xe2f7181d, 0x546dd84a, 0xad7bd802, 0x8848727c, 0x5204c8d5, 0x15cc471f, 0x06c461a6, 0x758f0bb4, 0x0af98f85, 0x49f887aa};

	#elif MULT_TESTVECTOR == 4
	uint32_t a[32] = 				{0xf484e847, 0x4ae251f1, 0xedfa617d, 0x58ab6bf4, 0x46bf4848, 0xf67c1061, 0x8811c17a, 0x578fde16, 0x493ee595, 0x1eafc4c3, 0xc4f11a2e, 0x8cb6fba7, 0x724c03a4, 0x2e6c1dbd, 0x57ebc43d, 0x3e6ee260, 0x4089c050, 0xf0384e03, 0x7357f72c, 0x87acb658, 0x7ea2490e, 0x61069112, 0x42e3f8b9, 0x9e778cef, 0x5cdf77c7, 0x10bce41c, 0x1121beec, 0x3db59a36, 0xc34620c5, 0xc6b030ae, 0xe8fc5934, 0x63a0a0cb};
	uint32_t b[32] = 				{0xfeb1b9f4, 0xe91d3bec, 0xfb09354d, 0x07f21d6d, 0x9ece9e1b, 0x18def18b, 0x4119e1e9, 0x55c85f24, 0x60ef0e23, 0x10e8ab54, 0x1e95cdcc, 0x4373912f, 0x6f42204d, 0x7126650d, 0xb61c1c8d, 0x98af9011, 0xa42c03b4, 0xd29e0870, 0x7923cb60, 0xdf87cfe5, 0xde4fffa0, 0x3ce537ca, 0x201040c6, 0x6e54b058, 0x814c53dc, 0xf16243f0, 0x57decf64, 0x8d0d4f37, 0x9b6d93e5, 0x45396d71, 0x615213c4, 0x65f89f9f};
	uint32_t N[32] = 				{0x4aeeb107, 0x5d78aa98, 0x6c55dd05, 0x6f5326c9, 0xf93f738c, 0xc10fa093, 0x20478120, 0x099d6d70, 0x833d9b82, 0x1248f3ed, 0xa43ed737, 0xc1c1da45, 0x9f23e5c7, 0xb17c3598, 0xe8938df6, 0x7ae59036, 0x9f84d87b, 0xc8710dc6, 0x249ee0f8, 0x46eeae2f, 0x66a3bb9b, 0xfeef4c6b, 0xc7b55eae, 0x7951dd0c, 0x0b4391e8, 0x141ad586, 0x1a568588, 0x908293dd, 0x472c0bea, 0x8d00abfe, 0xed17377f, 0x83a01efe};
	uint32_t n_prime[32] = 			{0xe7d41349, 0x0c828dcd, 0x2dc06d90, 0x318f87bf, 0x1992ba09, 0x4b1bef10, 0x011ba664, 0xe3a7d9cf, 0x44449fbd, 0x89714d34, 0x6cd49cc4, 0x49c5b99d, 0xf90435b1, 0x38f037b7, 0xba9720db, 0x9641b106, 0xbca01d2a, 0xfdb82893, 0xbd7ce9c7, 0x372823e1, 0x4901cdde, 0xaa28d457, 0xe9f78c94, 0xb6e1e5b3, 0x5a79f7a6, 0xf5212a83, 0x2b1aab45, 0xa3924b69, 0x3c63a8af, 0x12fa121d, 0x7500bea0, 0xe58878e7};
	uint32_t expected_output[32] = 	{0xeb7e3ef3, 0x40b90c4f, 0xd9c234b1, 0x2461cd34, 0x183481c7, 0x0bc4e5bd, 0x4803996e, 0x755d1777, 0x698f88c7, 0x2e78b03b, 0xa55cfb32, 0x74d1c12a, 0xc6bc8934, 0x581d4714, 0x7d504a58, 0xb29753f1, 0x99ae0c37, 0x65c4cc3a, 0x4153aacb, 0xe0a5c4bf, 0xce0a9c7c, 0x4babfb22, 0x75aa490d, 0x43b6ec25, 0xdcb17a10, 0x47deec3c, 0xd0e2735f, 0x16726b8e, 0x0f486246, 0x0f74d471, 0xe62a3577, 0x065a0397};

    #endif

	// Code Jasper semester 2 from montgomery2.c
	mont_mult(a, b, N, n_prime, result, 32);

	// Code semester 1 from sw.c
	// montgomery_multiply(A16, B16, N16, N_prime16, result, 16);

	printMontResult(32);
	xil_printf("Expected ");
	printArray(expected_output, 32);

	if (memcmp(result, expected_output, 32) != 0) {
		xil_printf("Software montgomery mult failed\r\n");
		abort();
	}

	xil_printf("Test software montgomery mult succeeded\r\n");
}

void test_hw_mont_mult() {
	#define HW_MONT_MULT_TESTVECTOR 5

	#if HW_MONT_MULT_TESTVECTOR == 1
	uint32_t A16[16] = 				{0x51977946, 0x7957b1be, 0x9f030fbd, 0x04561a82, 0x1fad9525, 0xab8e0526, 0x05c0a4a8, 0x4dcc3907, 0xc8ae12c7, 0x8b7d54ca, 0x22e43d05, 0x806b8cac, 0x13cbfd6b, 0x36d3028f, 0x52132ef0, 0xc51931a9};
	uint32_t B16[16] = 				{0x5fc3d1ef, 0x96dec894, 0x2d5929f7, 0xc0810a9f, 0x8b55af12, 0x3548fef6, 0x3d61e914, 0xc5784013, 0x20669791, 0x154a73de, 0x98e985d3, 0xe3d56445, 0xcb4fba56, 0x5f0012cc, 0xca83b655, 0xb220f8c0};
	uint32_t N16[16] = 				{0x0ebd5f75, 0x948cb7ab, 0x58727656, 0x0f02d0b4, 0x6ed897f2, 0x052304af, 0xcea1ed9f, 0x2e3b3a4c, 0xaa19906f, 0x0a3be041, 0x6ae0754b, 0x28470c40, 0xc871a4de, 0x10943525, 0x105d393e, 0xc6bb131b};
	uint32_t expected_output[16] = 	{0x9e31ea81, 0xe265cbb7, 0x5e453a5a, 0xffe854d5, 0x58b4d35b, 0x5370eae7, 0xfd0d421a, 0x66dd18b8, 0x7b232ec6, 0xb6df247f, 0x3f359f29, 0x4c244688, 0xc901b64c, 0xda554d8d, 0x7e49f069, 0x9712a929};

	#elif HW_MONT_MULT_TESTVECTOR == 2
	uint32_t A16[16] = 				{0xbaf3f13d, 0x3d48382a, 0xf0dae4f3, 0x9d8bf767, 0xc95550e2, 0xb365a6ca, 0x03020227, 0xeab17e8f, 0xee315b4e, 0xb3f8de91, 0x06d4fe65, 0x5fbc9aae, 0x8bd7b2a7, 0xdc1cecdb, 0xa5fe5cb6, 0x087bd031};
	uint32_t B16[16] = 				{0x2b406a1f, 0xcfb1b4be, 0x6c0e64b2, 0x38e5d252, 0xa9f6e1d3, 0x1d5f918e, 0x756b5fea, 0xfc70a562, 0xa2e27c64, 0x4869a6ea, 0x143850a9, 0x4ddf8edb, 0xfe6bed6c, 0x853b4af0, 0x258466ec, 0x03028f0f};
	uint32_t N16[16] = 				{0x0fbe29d3, 0x7a6e2ad9, 0x20b9da4b, 0xe3ab7787, 0x63559705, 0x0548c948, 0x5c5083d7, 0xc567882a, 0xa1c1a53d, 0x5ea047b9, 0xf674df8f, 0xc9a5235c, 0x1c44ba80, 0x20bc0ad8, 0x3d770d40, 0xf47bc3b5};
	uint32_t expected_output[16] =  {0x5c99333f, 0xb8b8219c, 0x974e2f8e, 0x577230ac, 0xf3df736e, 0x99f734c8, 0x94933ce5, 0x6b207105, 0x80ff4f40, 0x0f93708f, 0xa09de9ef, 0xa6c39779, 0xb4fea621, 0x57069fec, 0x8a5628f4, 0x7fa6e824};

	#elif HW_MONT_MULT_TESTVECTOR == 3
	uint32_t A16[16] = 				{0x394bb869, 0x0ac85ad8, 0x2e0ae82e, 0x35380963, 0xa6734271, 0x66a29154, 0xb5f0eb8c, 0xf75e26b4, 0x6dd116da, 0x965705bf, 0x85ee3e98, 0xcf3c9f9a, 0x289bc924, 0x3d23d751, 0x77a26eee, 0xae8a1514};
	uint32_t B16[16] = 				{0x521da139, 0x184b0dad, 0xd153e4f3, 0x56032052, 0xcb8d25a4, 0x8acbeab9, 0x7d07f88c, 0xaadcaea1, 0x0fa09f2e, 0x7b230769, 0x65750b15, 0x1715b574, 0xc7c5b2df, 0xb9718bea, 0x7f3da325, 0x96952c75};
	uint32_t N16[16] = 				{0x3a5a2fe1, 0x06282557, 0xdd8a0cf7, 0xe9f5a682, 0x4d6b648a, 0x78fb7a78, 0x749fe9d8, 0x40855018, 0xb459a4a2, 0x5ebe1521, 0xb80efcda, 0xc86622f7, 0x9a083ca2, 0x28cfadda, 0x369d9902, 0xafd40356};
	uint32_t expected_output[16] =  {0x965eae17, 0xb4316f86, 0xc020d2e8, 0xbb265a05, 0xb0f1d1dc, 0xf5434089, 0x1ba9a7ef, 0xc12627f1, 0xfeeb7ed4, 0xdcde67cf, 0x13583024, 0x6d895c9f, 0x8cccf3bf, 0xad1020f2, 0x7bc22ac2, 0x600d3758};

	#elif HW_MONT_MULT_TESTVECTOR == 4
	uint32_t A16[16] = 				{0x5f3e75e6, 0xc08fa6c3, 0x643473d1, 0x1eff0f99, 0x39483aee, 0xb680ad01, 0x6d393c9a, 0xd684cb28, 0x5e89931d, 0x40cc32dc, 0xd9f90da9, 0x2217fb3a, 0x5ab7eebd, 0xedf9cd68, 0xd6dec48d, 0x3ccbb89e};
	uint32_t B16[16] = 				{0x2ef60fd0, 0xc5ee76dc, 0xbf02bafa, 0x0750058d, 0x2ef0bf03, 0x041f5a19, 0x0602feea, 0xd53bf718, 0x53983960, 0x034b0262, 0x3a212201, 0x1cae2854, 0x4dd916b4, 0x29755811, 0xf9257b18, 0x3ba8ea30};
	uint32_t N16[16] = 				{0xad534215, 0x79edc1b4, 0x8f1e3221, 0x5acae35e, 0x9ab95cc4, 0x193f63d2, 0x025b8522, 0x098ae441, 0x9381690d, 0x5a6d61a8, 0xa3b05b56, 0x08d00149, 0x874f15f3, 0x972a08ec, 0x6328529f, 0xa58cc33e};
	uint32_t expected_output[16] = 	{0xf5a6cd97, 0xf8963f1a, 0x664a2281, 0x2b748cfd, 0x18d433d0, 0xb36528fa, 0x585b3d53, 0x03dcf1ee, 0xeb636354, 0xa2c8fd98, 0x73c19b5e, 0x67a1446b, 0xf89bfb05, 0xdff54a43, 0xc9ab43c6, 0x1d2662ce};

	#else // HW_MONT_MULT_TESTVECTOR
	uint32_t A16[16] =			 	{0xe99c0d36, 0xf9c07fe3, 0xcc848d93, 0x0995e07a, 0xb0fd3fa7, 0xe8a63fff, 0x65f0c2fc, 0x7786425f, 0xa53b20f0, 0x6ac46232, 0xf0acb0d0, 0x0b1ff924, 0x1285dd24, 0xc9022bad, 0x27cc58be, 0x8e999818};
	uint32_t B16[16] = 				{0x33ffe466, 0xa7cce3ca, 0xcdeba809, 0x8b28a43a, 0x8585f217, 0xef68d195, 0xa26b94ef, 0x38fb80ff, 0xb944284d, 0x639149e8, 0xd5da2b1a, 0x91d6c518, 0x2c51e12a, 0xb3e733d3, 0xb106897b, 0x3e1fc5f4};
	uint32_t N16[16] = 				{0xa51a5baf, 0x947ab35c, 0xaed3b9a8, 0x3aebb0f7, 0x247ff270, 0xf8f5314a, 0x1220cd68, 0x26f54d7b, 0xa151284d, 0xfc80b8e2, 0x53f8d7e4, 0x8a239ec4, 0xe79e52ca, 0x2c660ebc, 0xf75c4534, 0x92c96dcd};
	uint32_t expected_output[16] =  {0x597ef324, 0xe96cb8ec, 0x1ac62a8e, 0x85c59cd4, 0x498d19ad, 0x16017e18, 0x7dca7d36, 0x3db0199a, 0xa5f3c3cb, 0x3082e129, 0x6152e22c, 0x9965143d, 0xe51aa7ed, 0x79851fe0, 0xa63a4a1d, 0x54dd8102};

	#endif

	hw_montgomery_multiply((unsigned int*) A16, (unsigned int*) B16, (unsigned int*) N16, (unsigned int*) result, 16);
	printMontResult(16);
	xil_printf("Expected: \r\n");
	printArray(expected_output, 16);

	if (memcmp(result, expected_output, 16) != 0) {
		xil_printf("Hardware montgomery mult failed\r\n");
		abort();
	}

	xil_printf("Test hardware montgomery mult succeeded\r\n");
}

void test_mont_exp() {

#define EXP_TESTVECTOR 1

    #if EXP_TESTVECTOR == 1
    // message
    uint32_t X[32] = {0xd1f72277, 0x5bcebff7, 0x0f28d9ed, 0xe43362d8, 0xc5c6c315, 0x855753eb, 0xcb9978eb, 0xb04d99ad, 0x01c7c457, 0x2b5ccae1, 0x2b623a24, 0x4d9ce47f, 0x70f0f243, 0xc770f081, 0x67f34a9b, 0x18229f68, 0xdf327808, 0x00a34197, 0x0525ffdb, 0xf4b5797c, 0xdc1eed8f, 0xa115f7e8, 0x35e7960a, 0x7ec4d255, 0x7ec475ec, 0x6184c174, 0x8f3ef993, 0x0df6bbaa, 0x22928bf8, 0x6f58f75d, 0x00121ef8, 0x8736b775};
    // modulus
    uint32_t M[32]       = {0xbbfc20bd, 0x36ad0309, 0x4fae157f, 0xc4ea08c0, 0x0d37681c, 0x07e72b82, 0xf345dca3, 0x4a723f88, 0xdcf5ac59, 0x06b8a6b2, 0x368a00f3, 0xdb7d2058, 0x2c9dbb28, 0x124e2690, 0xcdd19842, 0x5ae15e97, 0xe2bda701, 0x9d11ea54, 0xe18c6fc9, 0xe0c3160c, 0xa00703b0, 0x1e21f6b5, 0xaf942238, 0xbe210e79, 0xc2ca886b, 0x6c20ecb1, 0xfcafdd9e, 0xba6224ee, 0xf80d650a, 0xd3119ff0, 0x8149d93a, 0x88c7a0f9};
    uint32_t M_prime[32] = {0x7e1f256b, 0x83dbe076, 0x6640a5e5, 0x7b9efc19, 0xcda50596, 0xd7b39c97, 0x4d8cb877, 0x3dfed80f, 0x7bc6ab2b, 0x66833e2c, 0x544cf630, 0xea63f8c9, 0x24dd3f41, 0x0ceb1ef4, 0x7cda2f92, 0xd5521efe, 0x9cf36016, 0x12fbe409, 0x46775528, 0xd346ccda, 0xb184f914, 0x981b516b, 0x75eb8385, 0x39c7425d, 0x8733bd5c, 0xd2a971df, 0x4a718971, 0x093ce057, 0xc3268d0a, 0x89da0333, 0x587151e7, 0x66edd04d};
    // encryption exponent
    uint32_t E[32] = {0x0000ef6b};
    uint32_t exp_len = 16;
    // R mod N, and R^2 mod N, (R = 2^1024)
    uint32_t R[32]  = {0x4403df43, 0xc952fcf6, 0xb051ea80, 0x3b15f73f, 0xf2c897e3, 0xf818d47d, 0x0cba235c, 0xb58dc077, 0x230a53a6, 0xf947594d, 0xc975ff0c, 0x2482dfa7, 0xd36244d7, 0xedb1d96f, 0x322e67bd, 0xa51ea168, 0x1d4258fe, 0x62ee15ab, 0x1e739036, 0x1f3ce9f3, 0x5ff8fc4f, 0xe1de094a, 0x506bddc7, 0x41def186, 0x3d357794, 0x93df134e, 0x03502261, 0x459ddb11, 0x07f29af5, 0x2cee600f, 0x7eb626c5, 0x77385f06};
    uint32_t R2[32] = {0x22f47dee, 0xf5713476, 0x1cd271a5, 0xcaef844d, 0xe4dfe69e, 0x21310383, 0xa8d683ed, 0x8e3dafe0, 0x3850d425, 0xddd8c78f, 0x027ebe51, 0x69522c83, 0x5b87bdca, 0xed6b9fdd, 0x0a4a4a0b, 0x40e5cf13, 0xe01dc8cc, 0x2d59d31b, 0x48725aa8, 0x4042e36e, 0x9c136c2a, 0xff5afff6, 0xad2bbbce, 0x4805f182, 0x0f651f17, 0x07ba3e74, 0xb04591cf, 0x196464b7, 0x48754ce6, 0xe0983de5, 0x2e4875f2, 0x1356d001};
    uint32_t expected_output[32] = {0x06330823, 0xa8da499b, 0x7adae76a, 0xb8f64269, 0x3d6586b7, 0x59e065e8, 0x19a5670e, 0x883da67d, 0x800ae2b3, 0xb7386f60, 0x24721d27, 0x728e69da, 0xea509ffe, 0x45d521f1, 0x013ed688, 0x4c6ec24d, 0xc84323e9, 0xd271a4e2, 0x4480c8ef, 0x9b9ff918, 0x74d142e6, 0xf6a8061c, 0x18f37e45, 0x2786c35d, 0xa5d51ea9, 0x11ae0a3e, 0xdaf958c9, 0x34cd83ff, 0x8eef0f98, 0x8445fc71, 0xee2a38b5, 0x780946ec};

	#elif EXP_TESTVECTOR == 2
	uint32_t X[32] = {0xa1f9b6ce, 0xb2280607, 0x24236d19, 0x893c1d9f, 0xbba1e702, 0x889c65d7, 0x463c0845, 0x14dd5add, 0x95f2bdc1, 0x0544a782, 0xac7e26cc, 0x809595e4, 0x5ad6974d, 0x66fcb060, 0x2e36800a, 0x5a3df073, 0x519a860e, 0x7ed1d6a5, 0x2163f769, 0xc4d86c58, 0xd433da74, 0x4b5bcd6a, 0xede84ee3, 0x7eaf5dcb, 0xb2493458, 0x4ab389f4, 0xddfe0216, 0x812a9f4c, 0xc87937ee, 0xcf32f14e, 0xe18435a4, 0x90541eab};
	uint32_t M[32] = {0x4e6fc30b, 0x6d5f9033, 0x3ac93d69, 0x415df9fb, 0xd9652e87, 0x60a7aef2, 0x44b77c4d, 0x847fc030, 0x5cf21cd5, 0x535736da, 0x46ae1b11, 0xfddff04c, 0x84fd9c4b, 0x08cac904, 0x34a95116, 0x49fff604, 0xede53570, 0xbb09ad2c, 0xce07019a, 0x77d3b920, 0x06f3fbd7, 0x8fe6df35, 0xfce4611e, 0xf5072bc5, 0xaf3847f7, 0x2740a725, 0x90ecf0ea, 0x9389ce5e, 0x4e2e474e, 0x66f610cd, 0xac41f79a, 0x960979f7};
	uint32_t M_prime[32] = {0xb2398f5d, 0xe8bb9fa4, 0xa8dee45f, 0xb6e49a9a, 0x652d0405, 0xc9b0505c, 0x5c660752, 0x215439c4, 0xff8acd11, 0x580531cb, 0xed14607e, 0x09737250, 0x3795d3f1, 0x0dcb6f6a, 0x9fbf5fd0, 0xd250464a, 0xa02b3a11, 0xbcbf929b, 0x6e7770a4, 0x36c76dad, 0x1745e15d, 0xaf29ebac, 0xce6ec197, 0xcb747bf7, 0x3df912a0, 0xc5836e88, 0xa3832d3e, 0xad7925cc, 0xc160b4e9, 0xa7e9e3fe, 0x51356d8a, 0x20ef8590};
	uint32_t E[32] = {0x0000e417};
	uint32_t exp_len = 16;
	uint32_t R[32]  = {0xb1903cf5, 0x92a06fcc, 0xc536c296, 0xbea20604, 0x269ad178, 0x9f58510d, 0xbb4883b2, 0x7b803fcf, 0xa30de32a, 0xaca8c925, 0xb951e4ee, 0x02200fb3, 0x7b0263b4, 0xf73536fb, 0xcb56aee9, 0xb60009fb, 0x121aca8f, 0x44f652d3, 0x31f8fe65, 0x882c46df, 0xf90c0428, 0x701920ca, 0x031b9ee1, 0x0af8d43a, 0x50c7b808, 0xd8bf58da, 0x6f130f15, 0x6c7631a1, 0xb1d1b8b1, 0x9909ef32, 0x53be0865, 0x69f68608};
	uint32_t R2[32] = {0xafd67099, 0x1057b974, 0x5b5f30e3, 0x8abf56c9, 0x15aead5f, 0x007f37b8, 0xfc5e5375, 0xf354bc3d, 0x93f5cbd3, 0x129b3c53, 0xb185bce7, 0x553b5c6a, 0x69611f46, 0xaa095a06, 0xb1eaf678, 0x3b7bc563, 0xd0c17574, 0x10d9a47d, 0xd2346905, 0xc2c5d097, 0x1618fbe4, 0xf09131ef, 0x80173e25, 0x4eecd25c, 0xf05880a3, 0xfcd0e1aa, 0xb0be348f, 0x89353122, 0x49baf1b4, 0x9278de2c, 0x38832c11, 0x7263314d};
	uint32_t expected_output[32] = {0xab568cab, 0x8788884c, 0x73fc522c, 0x9089f061, 0xaa5f4254, 0xc0d32f7d, 0x3d58b41a, 0xa00a5263, 0x67534dde, 0xb5aa830e, 0xf718b281, 0xf99b3740, 0xeba63338, 0xadfe35b0, 0x041d57c0, 0x44d17209, 0x2a43baac, 0x432ac620, 0x206adf87, 0x7df68c65, 0xfe6ecab1, 0x973fe19d, 0xf6acfca0, 0xd197e90c, 0x6fcf86f7, 0x6ca237ba, 0xcb566216, 0x3237cd3b, 0xa9e65259, 0x13600ec6, 0xfb997871, 0x51aaa340};

    #elif EXP_TESTVECTOR == 3
	uint32_t X[32] = {0x22b3b2e5, 0x855e6eeb, 0xf97c2a24, 0x858f4dce, 0x18d08bc8, 0x2d779d59, 0x8e73afa3, 0xd662a4d1, 0x69b6a28a, 0x1dbf0a01, 0x7a091f53, 0xa6a24c08, 0x63f80a76, 0x909d0d22, 0xb9a92ee1, 0xd7fbd7d3, 0x9e2749f4, 0x5e91547f, 0xb01b886a, 0x160217b4, 0x5504f213, 0x777e690f, 0x5c41564b, 0x266fea1e, 0x14266d31, 0xd6406cff, 0x58ac507f, 0xf8104dd2, 0xefb99905, 0x6765a442, 0xc3fd3412, 0xa4d1cbd5};
	uint32_t M[32] = {0x2e4a4371, 0xdf1fb2bc, 0x6d4da708, 0xe68cfda7, 0x365c1a65, 0x45bf37df, 0x0dc8b4bd, 0xa151af5f, 0xf55bccc0, 0xfaa31a4f, 0xe5644738, 0x4effd6fa, 0x219a7372, 0x98488e9c, 0x90c4bd70, 0xaccbdd7d, 0xd49b83bf, 0x24975c3c, 0xa9061123, 0x13ecb4ae, 0x2ee652c0, 0x9838ef1e, 0x75a23d18, 0x6073e286, 0x52d23b61, 0x9a6a9dca, 0xfb06a3c6, 0x52c99fbc, 0xae5d54ec, 0xde92de5e, 0xa080e01d, 0xb10b8f96};
	uint32_t M_prime[32] = {0xfaf3e26f, 0x75f08430, 0x6d8fcf12, 0xe8c5ba4b, 0x9e264809, 0xd351418a, 0x9f8b9d41, 0x6859d6be, 0xed66f277, 0xc5437adc, 0xcdd683f4, 0xbacb7c0b, 0x94e36b0a, 0x2c324f0f, 0xaa2e9ba1, 0x4fa8e2c1, 0x9ca6dcbb, 0x7de571e6, 0x24dd5717, 0xde25014d, 0x543b8e37, 0x2f0c55fa, 0x2db1fb0f, 0x320ec939, 0xa8b449b8, 0x4205c15c, 0x69554bc8, 0x388bc4a8, 0xc677c17b, 0xaa37657a, 0x91784afa, 0x51c8e809};
	uint32_t E[1] = {0x000ae417};
	uint32_t exp_len = 20;
	uint32_t R[32] = {0xd1b5bc8f, 0x20e04d43, 0x92b258f7, 0x19730258, 0xc9a3e59a, 0xba40c820, 0xf2374b42, 0x5eae50a0, 0x0aa4333f, 0x055ce5b0, 0x1a9bb8c7, 0xb1002905, 0xde658c8d, 0x67b77163, 0x6f3b428f, 0x53342282, 0x2b647c40, 0xdb68a3c3, 0x56f9eedc, 0xec134b51, 0xd119ad3f, 0x67c710e1, 0x8a5dc2e7, 0x9f8c1d79, 0xad2dc49e, 0x65956235, 0x04f95c39, 0xad366043, 0x51a2ab13, 0x216d21a1, 0x5f7f1fe2, 0x4ef47069};
	uint32_t R2[32] = {0x74aa5319, 0xc858a523, 0xb7606cc5, 0xe896dad3, 0xc46cff7c, 0xc81f66fb, 0x3888602d, 0x88a4e1b0, 0x01a1325d, 0x58e133b0, 0xee24e06c, 0x88913e20, 0xdb526dc0, 0x569160e0, 0xc675109f, 0xaa2ee84b, 0xea0736ad, 0xbbf724b4, 0x4dbd7ca7, 0xb6a3bb99, 0xba198811, 0x6ca21841, 0xe3939e0c, 0xd669f224, 0x3abd32e2, 0xc456f436, 0xd18062af, 0x8f62499e, 0xab9f57c1, 0x631df2a3, 0x9359aa23, 0xa6a24d2d};
	uint32_t expected_output[32] = {0xbe02a166, 0xe05fc340, 0x1c879fd9, 0xc4e09179, 0x60abbff5, 0x9f9bb209, 0x6af8aa61, 0xfa5e1c2d, 0x9fcf475a, 0xb3ff537b, 0xb35245b4, 0xfd212504, 0xe112e7d9, 0x5dbb498c, 0x167f7594, 0x0e83f430, 0x4cb08e2f, 0x7a10ef3d, 0x4f190a62, 0x01fa9c32, 0x0633db82, 0x19e8ddfd, 0x35e0008d, 0xc7aa4183, 0x33337b64, 0xfca5658d, 0x0134dde3, 0xb8a5b65a, 0x4a3324de, 0x86cfbed4, 0x1a039bb2, 0x1c9316ac};

    #elif EXP_TESTVECTOR == 4
	int32_t X[32] = {0x6bd93cbd, 0x2ebfb2c7, 0x7cf9e776, 0xe4187535, 0x66a33b10, 0x065afad6, 0x975f73d4, 0x496fb60b, 0x28529fbe, 0xc140401f, 0x7eeb31e2, 0xef45f639, 0xe5c0b738, 0xdb2ac5f3, 0x79802c83, 0x1f1b89c3, 0xbf7eaa58, 0xd45a55ba, 0xab819d74, 0xa6d3bd6f, 0x0482976d, 0xfec7eb1e, 0xf32906b7, 0x652d4084, 0x22033068, 0x36124322, 0x9f76d1a1, 0x6da7ec88, 0x5eacf0a4, 0xd1a8728e, 0xf8cc6ab0, 0xb02f6148};
	uint32_t E[1] = {0x0000b330};
	uint32_t exp_len =  16 ;
	uint32_t M[32] = {0xfde33b8f, 0xbaab11a1, 0x3c8c893c, 0xb1500200, 0xf9d24bba, 0xe222d5c3, 0x6cac296c, 0xb98e5642, 0x673bb3df, 0xbf622e6f, 0xcde92e10, 0x5b70b0f8, 0xbc0af8ba, 0x26111490, 0x930334b9, 0x66277177, 0x0e5f81f5, 0x7bfcaf4b, 0x8411f03a, 0xd0173f99, 0xd32ec72e, 0x53bdcc72, 0xcff9bece, 0x9aa667a9, 0x6fe3a78c, 0x02c749b4, 0xb1097967, 0x590ecd2d, 0x47583048, 0x56369bca, 0x3c5ee883, 0xd47ce65d};
	uint32_t M_prime[32] = {0xd66e7c91, 0xc5b565a8, 0x3892fdf7, 0x31ccfc2c, 0x51f3c44e, 0x4eda9428, 0x882b0045, 0x40b44298, 0x4c14c80c, 0xf7a4f863, 0xe92fdb59, 0x689b1a21, 0x5bd4d3db, 0xd2021bfd, 0xa2173bab, 0xc9273af2, 0xd4e24d7c, 0x7ecc06b8, 0x93ad0a7e, 0x2848eb92, 0xa7686bf4, 0x85ac7173, 0x7f006423, 0x8b809826, 0x7e4c1de7, 0x8089306b, 0x99b4ca40, 0x3e8b96ea, 0x39f10350, 0x1f95753a, 0xe4500b0a, 0x25fb6099};
	uint32_t R[32] = {0x021cc471, 0x4554ee5e, 0xc37376c3, 0x4eaffdff, 0x062db445, 0x1ddd2a3c, 0x9353d693, 0x4671a9bd, 0x98c44c20, 0x409dd190, 0x3216d1ef, 0xa48f4f07, 0x43f50745, 0xd9eeeb6f, 0x6cfccb46, 0x99d88e88, 0xf1a07e0a, 0x840350b4, 0x7bee0fc5, 0x2fe8c066, 0x2cd138d1, 0xac42338d, 0x30064131, 0x65599856, 0x901c5873, 0xfd38b64b, 0x4ef68698, 0xa6f132d2, 0xb8a7cfb7, 0xa9c96435, 0xc3a1177c, 0x2b8319a2};
	uint32_t R2[32] = {0x26045bb8, 0xba193d95, 0xd20814ea, 0x19a75797, 0xfca712a6, 0x6b79d071, 0x3e3ddc88, 0x5221c132, 0x3486d53b, 0xc9d8e2d6, 0xaf41e254, 0xf196b1c4, 0x684ee3c1, 0xfa842770, 0xf24bd8f3, 0x5aade81a, 0x9e241aaf, 0xb124f0d0, 0xc3eab6fa, 0x3152f477, 0x5a3b6b5a, 0xc0b611fe, 0x8b7da09a, 0xe48206a5, 0xa49d1b4d, 0x1e325d7d, 0x7bc36905, 0x53c5c413, 0x42004279, 0x474987b3, 0x0d551915, 0x79cd4e0d};
	uint32_t expected_output[32] = {0x7b8b8b2b, 0xdf418dfd, 0xbc9b9a90, 0x9045168f, 0xf9693f5b, 0x08ae73eb, 0xb6e256c8, 0x703916b2, 0x15457095, 0x0f96215f, 0x6f55556f, 0xe82e4228, 0x02e95280, 0x2cb48c54, 0x8b2ff8c6, 0xa62d1978, 0x5a164faa, 0xebb41935, 0x7ded2df9, 0x6d1e6b7b, 0x3ee1749b, 0xf5748a36, 0x35688d90, 0xf73318f4, 0x1b508ad1, 0x8c821a1f, 0x05ab6332, 0x8cc46c1f, 0x2d33f2bb, 0x66ea8c0f, 0x326fcfb7, 0x2c844669};

	#elif EXP_TESTVECTOR == 5
    uint32_t X[32] = {0x6bd93cbd, 0x2ebfb2c7, 0x7cf9e776, 0xe4187535, 0x66a33b10, 0x065afad6, 0x975f73d4, 0x496fb60b, 0x28529fbe, 0xc140401f, 0x7eeb31e2, 0xef45f639, 0xe5c0b738, 0xdb2ac5f3, 0x79802c83, 0x1f1b89c3, 0xbf7eaa58, 0xd45a55ba, 0xab819d74, 0xa6d3bd6f, 0x0482976d, 0xfec7eb1e, 0xf32906b7, 0x652d4084, 0x22033068, 0x36124322, 0x9f76d1a1, 0x6da7ec88, 0x5eacf0a4, 0xd1a8728e, 0xf8cc6ab0, 0xb02f6148};
    uint32_t E[1] = {0x00000003};
    uint32_t exp_len =  2 ;
    uint32_t M[32] = {0x3b6021e5, 0x134c079f, 0xfde33b8f, 0xbaab11a1, 0x3c8c893c, 0xb1500200, 0xf9d24bba, 0xe222d5c3, 0x6cac296c, 0xb98e5642, 0x673bb3df, 0xbf622e6f, 0xcde92e10, 0x5b70b0f8, 0xbc0af8ba, 0x26111490, 0x930334b9, 0x66277177, 0x0e5f81f5, 0x7bfcaf4b, 0x8411f03a, 0xd0173f99, 0xd32ec72e, 0x53bdcc72, 0xcff9bece, 0x9aa667a9, 0x6fe3a78c, 0x02c749b4, 0xb1097967, 0x590ecd2d, 0x47583048, 0xd6369bca};
    uint32_t M_prime[32] = {0xb7bfcc13, 0x913284a2, 0xdda7b6f2, 0x7a5c8583, 0x709ca502, 0xaa20b65c, 0xe603ebeb, 0x370f8de1, 0x6e6a026e, 0xd531c566, 0x1271e3eb, 0x732d0aed, 0x5f44d582, 0x3c5ebd20, 0x4625fb34, 0xbffb3ff7, 0x28b98ae5, 0x2fbac94d, 0xc26bafc9, 0xcae25e12, 0xb43b5053, 0x56971c37, 0x4bbeb19d, 0x0a85b251, 0x11df4432, 0xb449f6bb, 0x04e65bfb, 0x485edf78, 0x5f3c3876, 0xb7bbe9c9, 0x0734e9ad, 0x4a415b38};
    uint32_t R[32] = {0xc49fde1b, 0xecb3f860, 0x021cc470, 0x4554ee5e, 0xc37376c3, 0x4eaffdff, 0x062db445, 0x1ddd2a3c, 0x9353d693, 0x4671a9bd, 0x98c44c20, 0x409dd190, 0x3216d1ef, 0xa48f4f07, 0x43f50745, 0xd9eeeb6f, 0x6cfccb46, 0x99d88e88, 0xf1a07e0a, 0x840350b4, 0x7bee0fc5, 0x2fe8c066, 0x2cd138d1, 0xac42338d, 0x30064131, 0x65599856, 0x901c5873, 0xfd38b64b, 0x4ef68698, 0xa6f132d2, 0xb8a7cfb7, 0x29c96435};
    uint32_t R2[32] = {0xdbc1f8f5, 0xf0b21422, 0x0d5ce12d, 0x8bf6674a, 0x79da5d6c, 0x8b4c29bd, 0xd85013c5, 0xcb075991, 0x2d1b80ff, 0x1f7c5324, 0x9748937f, 0x66816f22, 0x7b5718bb, 0x81e6a3f3, 0xa2224052, 0x7c5571e1, 0x0425d5c9, 0x429c93b3, 0x82cdbd69, 0x26200729, 0x8d9e7da4, 0x0360fe11, 0x8cf166a3, 0xafcf3310, 0x00d3f832, 0x10bc759b, 0x310def28, 0x4e09dc91, 0x3508c858, 0xd2b5d271, 0x262f767d, 0x7a23eae8};
    uint32_t expected_output[32] = {0x2ce21a20, 0xcb5b9814, 0x90605b33, 0x5af59716, 0x4f07ec4e, 0x64ea8d10, 0xde81ea17, 0xc0d2aa89, 0x95da6afe, 0x0b67fed5, 0x4185b338, 0xa908a2ec, 0x82d658a6, 0x1bda310b, 0xbe5edaf9, 0xffd21728, 0xf160971e, 0xd5579fae, 0x71453ff5, 0x725784c3, 0x108131a3, 0xca63c353, 0x798a79c7, 0xf07786b1, 0x134f0a9a, 0xad1972c0, 0x28c52783, 0x31a1df14, 0xa9a52606, 0xef06cd59, 0x226a15b4, 0x6d039b24};

	#else // EXP_TESTVECTOR == 6
    uint32_t X[32] = {0x5204a0f4, 0x471df4bc, 0x2943dabc, 0xb33cf03c, 0x6c3700c0, 0x9c2e40a2, 0x6adfcf1e, 0x6ea31cc6, 0x54640571, 0x251b5eac, 0x783b7589, 0x473fe47b, 0xe36d9e78, 0x57153d0b, 0x8696b918, 0x1a4fd6c0, 0x4c3a0ab4, 0xd663800e, 0xe6c7efa5, 0xe773fa73, 0x98419280, 0x65441264, 0x6a749096, 0x320a57ae, 0xbfe4daaa, 0x229ec3a6, 0x60a6aee8, 0x68dac070, 0xb3d00628, 0xd7a3120a, 0xb02aa62c, 0x90f35c6d};
    uint32_t E[1] = {0x00000003};
    uint32_t exp_len =  3 ;
    uint32_t M[32] = {0x0ef31747, 0xf3d8b0d7, 0xa8de9738, 0xece35114, 0xe0643aba, 0x46dd62bd, 0xc2005261, 0xe1e83167, 0xa50b0b7c, 0xb6c38903, 0x609f2ad9, 0x310a9fc2, 0x5bee620f, 0x1ff62a17, 0x6ff4d2bd, 0x10e5d3fb, 0xe4df395b, 0xa78de346, 0x10213dc3, 0xea1ac1ed, 0xd458eb04, 0xe438c468, 0x28800b75, 0x02ec2efe, 0xd24f68c9, 0xb8e75ae3, 0x9f7c00eb, 0xcb45d78b, 0x38ec9502, 0x474556ce, 0x0cf424ed, 0xe4f390d5};
    uint32_t M_prime[32] = {0x154e9d89, 0xfd21221c, 0xea40621f, 0x9d2592ca, 0xdb2dfd37, 0xa1b3cca1, 0xd0d37e5b, 0x519b0a73, 0x332094ae, 0x2c6de6a8, 0x5baabe3e, 0xb58420e1, 0xd6198fb8, 0x5fd0a147, 0x685f43bd, 0x463668d0, 0xe203c9e0, 0x45d53656, 0x2413e640, 0x54bc3a78, 0x82fcabaa, 0x02808516, 0x92876bb3, 0x27ad12d7, 0x0d03d700, 0x147dcbd1, 0x47f0325f, 0x7ad15049, 0x26b7ce29, 0xcda191e3, 0x5ce38f4d, 0x2449ee60};
    uint32_t R[32] = {0xf10ce8b9, 0x0c274f28, 0x572168c7, 0x131caeeb, 0x1f9bc545, 0xb9229d42, 0x3dffad9e, 0x1e17ce98, 0x5af4f483, 0x493c76fc, 0x9f60d526, 0xcef5603d, 0xa4119df0, 0xe009d5e8, 0x900b2d42, 0xef1a2c04, 0x1b20c6a4, 0x58721cb9, 0xefdec23c, 0x15e53e12, 0x2ba714fb, 0x1bc73b97, 0xd77ff48a, 0xfd13d101, 0x2db09736, 0x4718a51c, 0x6083ff14, 0x34ba2874, 0xc7136afd, 0xb8baa931, 0xf30bdb12, 0x1b0c6f2a};
    uint32_t R2[32] = {0x8f64843f, 0x5175009b, 0x19d49251, 0x9db2b2bc, 0x01895be9, 0x791a5d68, 0xf27e294d, 0xcdd27b1e, 0x31f7003c, 0x92caf811, 0x5cbce177, 0xec50ef16, 0x32570b0e, 0x2f099ce6, 0xb7899400, 0x5171f544, 0x9fde17a7, 0x8a9f7b58, 0x3c6448df, 0x3955c76c, 0xb3997a51, 0x225212bf, 0x3d4d276b, 0x7eb5f44e, 0x8dcdac09, 0x7c9a75cb, 0xc84bef22, 0x017050c7, 0xe3b95aae, 0x5dba2812, 0x2f27c903, 0x8ad3e22c};
    uint32_t expected_output[32] = {0x605d5def, 0x3bd4b0bb, 0x5e4f8e7d, 0x58c4ba04, 0x9f51fc53, 0xd2c7171a, 0x3f6ebaba, 0x4936915a, 0xcb2b8c88, 0x5c3b2b45, 0x35f3331b, 0x0022c7b3, 0xd7f12aa0, 0x1ddb9c32, 0x0a3cdfa7, 0x203142ec, 0x76592cca, 0x17cd037e, 0x7c60c0b5, 0x57723806, 0x8cd291c2, 0xc4111f92, 0x9be3cd93, 0x5610a1a7, 0x3bd0c778, 0x48b723b5, 0x2034c6e4, 0x79c82cfe, 0xad6997ed, 0x85d25a75, 0x54c4b7ea, 0x8aab9d60};

    #endif

	mod_exp(X, E, exp_len, M, M_prime, R, R2, result);

	xil_printf("\r\n");
	printMontResult(32);
	xil_printf("Expected ");
	printArray(expected_output, 32);

	if (memcmp(result, expected_output, 32) != 0) {
		xil_printf("Software montgomery exp failed\r\n");
		abort();
	}

	xil_printf("Test software montgomery exp succeeded\r\n");

}


//void test_hw_mont_exp() {
//	hw_mod_exp(Ct_p,d_p, d_p_len, p, Rp, R2p, result);
//}


void test_hw_mont_decrypt() {
	unsigned int Cp[16];
	unsigned int Cq[16];
	uint32_t Pp[16];
	uint32_t Pq[16];
	reduce_cipher((unsigned int*)result, Cp, Cq);
	uint32_t *nCp = (uint32_t*)Cp;
	uint32_t *nCq = (uint32_t*)Cq;
	hw_mod_exp(nCp, d_p,d_p_len, p, Rp, R2p, Pp);
	hw_mod_exp(nCq, d_q,d_q_len, q, Rq, R2q, Pq);
	combineResult(Pp, Pq, result);
}

void printMontResult(uint32_t size)
{
	int i;
	if (result[size-1] != 0) {
		xil_printf("Result:0x%x", result[size-1]);
	} else {
		xil_printf("Result: 0x");
	}
	for (i=size-2; i>=0; i--) {
		xil_printf("%08x", result[i]);
	}
	xil_printf("\n\r \n\r");
}
